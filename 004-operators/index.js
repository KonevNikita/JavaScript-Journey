// В JS много операторов - на момент составления конспекта 50. Операторы можно разделять на различные группы: по числу операндов,
// цели применения, алгебраическим свойствам (ассоциативности) и по положению в таблице приоритетов операторов.
// Одним из самых распространенных операторов в JS является оператор присваивания. У оператора присваивания один из самых низких
// приоритетов.
let a = 42;

// Оператор присваивания возвращает значение.
let b, c;
c = b = 0;

// У оператора присваивания есть аналоги для модификации значения.
let d = 42;
d += 2;
// Выведет 44
console.log(d);
d /= 2;
// Выведет 22
console.log(d);

// Некоторые операторы имеют возможность получать информацию о значении.
console.log(typeof d);
// Оператор instanceof проверяет, является ли значение по левую сторону экземпляром класса по правую сторону.
// Следует обратить внимание на то, что примитивные типы не являются экземплярами классов, а тип строковых литералов не является
// классом.
console.log(d instanceof Number);
console.log('hello' instanceof String);

// Для примитивных типов вместо instanceof следует использовать typeof.
console.log(typeof d === 'number');
console.log(typeof 'hello' === 'string');

// В JS есть два вида равенства: строгое и нестрогое.
console.log(3 == '3');
// В отличие от нестрогого равенства, строгое не производит конверсию типов.
// В профессиональной разработке чаще всего рекомендуют использовать строгое равенство или неравенство.
console.log(3 === '3');

// async await - это операторы для асинхронного программирования. Это сложная тема, и мы ее разберем позже.
// delete - удаляет свойство из объекта. Это может быть полезно в случае наличия круговых зависимостей: когда переменная
// ссылается на саму себя через свои свойства, из-за чего сборщик мусора не может ее удалить.
// void - вычисляет выражение по правую сторону и возвращает undefined. Используется для IIFE - immediately invoked function
// expressions - немедленно вызываемых функциональных выражений.
// Группировка (круглые скобки) - для изменения порядка операций при вычеслении выражений.
// new - создание экземпляра класса, на котором далее можно будет использовать instanceof.
console.log(new String('hello') instanceof String);

// Доступ к свойствам объекта (.) - для получения значения из объекта на основе идентификатора. Объект - это некоторый набор пар,
// где для каждого значения - ключа, ставится в соответствие некоторое значение.
let obj = {"key":"value"};
console.log(obj.key);

// Доступ к свойствам объекта с вычислением ([<выражение>]). Для получения значения из объекта на основе выражения.
console.log(obj['k'+'e'+'y']);
// Тернарный условный оператор (<логическое выражение> ? <выражение, если true> : <выражение, если false>) - для выбора значения
// в зависимости от логического выражения.
let isActive = false;
console.log(`system is ${isActive ? '' : 'in'}active`);

// Вызов функции ((<аргументы>)).

// Оператор опциональной последовательности (?.) - используется для получения значения свойства, не выбрасывая исключения, но возвращая
// "undefined" при значении равном "null" и "undefined". Используется, если есть вероятность отсутствия некоторых значений.
// Требует Node.js 14+
let e;
// для (?.) должна быть объявлена переменная
if (process.version.match(/^v(\d+).*/)[1] >= 14) {
    console.log(typeof(e?.string))
} else {
    console.log('optional chaining is not supported for Node.js 13 and below')
}

// Операторы постфиксного инкремента (variable++) и декремента (variable--) возвращают значение variable [до изменения] и потом
// увеличивают или уменьшают значение variable на 1 соответственно. Это часто используется в циклах.
let idx = 0;
obj[idx++] = idx;
obj[idx++] = idx;
obj[idx++] = idx;
obj[idx++] = idx;
console.log(obj);

// Операторы префиксного инкремента (++variable) и декремента (--variable) сначала изменяют значение и только потом возвращают
// обновленное значение. Тоже часто используется в циклах.
idx = 0;
obj[++idx] = idx;
obj[++idx] = idx;
obj[++idx] = idx;
obj[++idx] = idx;
console.log(obj);

// Логическое отрицание (!) часто используют для конверсии значений контейнеров в соответствующие логические значения. С помощью
// логического отрицания проверяется, что они не пустые.
let arr = [1,2,3,4,5];
// Вместо использования ? можно было поменять местами операнды условного тернарного оператора ('' и "не").
console.log(`массив ${arr} ${!arr ? '' : "не"} пустой`);

// Унарные операторы (+) и (-) приводят значение к типу number. Оператор (-) после этого возвращает абсолютное значение числа с
// противоположным знаком. Это используется для оптимизации производительности, например, asm.js. Эти операторы при применении
// на строках пытаются распарсить строки как числа, возвращая NaN в случае неудачи.
console.log(+true);
console.log(+'tree');
console.log(+'3');

// Есть побитовые сдвиги, но они практически не используются в коде на JS для фронтенда. Аналогично с другими побитовыми операциями.

// Логические операции часто применяются интересным образом.
let noVal = null;
noVal = noVal || 42;
console.log(noVal);

obj = {'a' : 42}
console.log(obj && obj.a);
obj = null;
// Без obj && было бы брошено исключение при попытке прочитать значение атрибута объекта null.
// Эта идиома является устаревшей с появлением оператора Optional chaining (?.).
console.log(obj && obj.a);

// Оператор нулевого слияния (??) аналогично оператору логического ИЛИ (||) позволяет инициализировать неициализированные
// переменные, но, в отличие от него, не трогает инициализированные ложноподобные (falsy) выражения, то есть все ложноподобные, кроме
// undefined и null.
const baz = 0 ?? 42;
console.log(baz);
const arr1 = [] ?? [666];
console.log(arr1);

// yield и yield* используются для создания функций-генераторов.

// Оператор (,) позволяет выстраивать вычисления в цепочки, возвращая последнее значение. Это может иметь смысл в операторе for, но
// настоятельно рекомендуется сопровождать такой код комментарием.

// Это не кортеж - пара.
let x = (2,3);
console.log(x);

